import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash.memoize/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.memoize/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    module.exports = memoize;
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/cytoscape-edgehandles/cytoscape-edgehandles.js
var require_cytoscape_edgehandles = __commonJS({
  "node_modules/cytoscape-edgehandles/cytoscape-edgehandles.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_lodash(), require_lodash2());
      else if (typeof define === "function" && define.amd)
        define(["lodash.memoize", "lodash.throttle"], factory);
      else if (typeof exports === "object")
        exports["cytoscapeEdgehandles"] = factory(require_lodash(), require_lodash2());
      else
        root["cytoscapeEdgehandles"] = factory(root["_"]["memoize"], root["_"]["throttle"]);
    })(exports, function(__WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_14__) {
      return (
        /******/
        (function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.i = function(value) {
            return value;
          };
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 12);
        })([
          /* 0 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            module2.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {
              for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                srcs[_key - 1] = arguments[_key];
              }
              srcs.filter(function(src) {
                return src != null;
              }).forEach(function(src) {
                Object.keys(src).forEach(function(k) {
                  return tgt[k] = src[k];
                });
              });
              return tgt;
            };
          }),
          /* 1 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var Edgehandles = __webpack_require__(10);
            var assign = __webpack_require__(0);
            module2.exports = function(options) {
              var cy = this;
              return new Edgehandles(assign({ cy }, options));
            };
          }),
          /* 2 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            function disableGestures() {
              this.saveGestureState();
              this.cy.zoomingEnabled(false).panningEnabled(false).boxSelectionEnabled(false);
              if (this.options.disableBrowserGestures) {
                var wlOpts = this.windowListenerOptions;
                window.addEventListener("touchstart", this.preventDefault, wlOpts);
                window.addEventListener("touchmove", this.preventDefault, wlOpts);
                window.addEventListener("wheel", this.preventDefault, wlOpts);
              }
              return this;
            }
            function resetGestures() {
              this.cy.zoomingEnabled(this.lastZoomingEnabled).panningEnabled(this.lastPanningEnabled).boxSelectionEnabled(this.lastBoxSelectionEnabled);
              if (this.options.disableBrowserGestures) {
                var wlOpts = this.windowListenerOptions;
                window.removeEventListener("touchstart", this.preventDefault, wlOpts);
                window.removeEventListener("touchmove", this.preventDefault, wlOpts);
                window.removeEventListener("wheel", this.preventDefault, wlOpts);
              }
              return this;
            }
            function saveGestureState() {
              var cy = this.cy;
              this.lastPanningEnabled = cy.panningEnabled();
              this.lastZoomingEnabled = cy.zoomingEnabled();
              this.lastBoxSelectionEnabled = cy.boxSelectionEnabled();
              return this;
            }
            module2.exports = { disableGestures, resetGestures, saveGestureState };
          }),
          /* 3 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            function addCytoscapeListeners() {
              var _this = this;
              var cy = this.cy, options = this.options;
              this.addListener(cy, "drag", function() {
                return _this.grabbingNode = true;
              });
              this.addListener(cy, "free", function() {
                return _this.grabbingNode = false;
              });
              this.addListener(cy, "tapstart", "node", function(e) {
                var node = e.target;
                if (_this.drawMode) {
                  _this.start(node);
                }
              });
              this.addListener(cy, "tapdrag", function(e) {
                _this.update(e.position);
              });
              this.addListener(cy, "tapdragover", "node", function(e) {
                if (options.snap) {
                } else {
                  _this.preview(e.target);
                }
              });
              this.addListener(cy, "tapdragout", "node", function(e) {
                if (options.snap) {
                } else {
                  _this.unpreview(e.target);
                }
              });
              this.addListener(cy, "tapend", function() {
                _this.stop();
              });
              return this;
            }
            module2.exports = { addCytoscapeListeners };
          }),
          /* 4 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var defaults = {
              canConnect: function canConnect(sourceNode, targetNode) {
                return !sourceNode.same(targetNode);
              },
              edgeParams: function edgeParams(sourceNode, targetNode) {
                return {};
              },
              hoverDelay: 150,
              // time spent hovering over a target node before it is considered selected
              snap: true,
              // when enabled, the edge can be drawn by just moving close to a target node (can be confusing on compound graphs)
              snapThreshold: 50,
              // the target node must be less than or equal to this many pixels away from the cursor/finger
              snapFrequency: 15,
              // the number of times per second (Hz) that snap checks done (lower is less expensive)
              noEdgeEventsInDraw: true,
              // set events:no to edges during draws, prevents mouseouts on compounds
              disableBrowserGestures: true
              // during an edge drawing gesture, disable browser gestures such as two-finger trackpad swipe and pinch-to-zoom
            };
            module2.exports = defaults;
          }),
          /* 5 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            function toggleDrawMode(bool) {
              var cy = this.cy;
              this.drawMode = bool != null ? bool : !this.drawMode;
              if (this.drawMode) {
                this.prevUngrabifyState = cy.autoungrabify();
                cy.autoungrabify(true);
                this.emit("drawon");
              } else {
                cy.autoungrabify(this.prevUngrabifyState);
                this.emit("drawoff");
              }
              return this;
            }
            function enableDrawMode() {
              return this.toggleDrawMode(true);
            }
            function disableDrawMode() {
              return this.toggleDrawMode(false);
            }
            module2.exports = { toggleDrawMode, enableDrawMode, disableDrawMode };
          }),
          /* 6 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var assign = __webpack_require__(0);
            var isString = function isString2(x) {
              return (typeof x === "undefined" ? "undefined" : _typeof(x)) === _typeof("");
            };
            var isArray = function isArray2(x) {
              return (typeof x === "undefined" ? "undefined" : _typeof(x)) === _typeof([]) && x.length != null;
            };
            function getEleJson(overrides, params, addedClasses) {
              var json = {};
              assign(json, params, overrides);
              assign(json.data, params.data, overrides.data);
              if (isString(params.classes)) {
                json.classes = params.classes + " " + addedClasses;
              } else if (isArray(params.classes)) {
                json.classes = params.classes.join(" ") + " " + addedClasses;
              } else {
                json.classes = addedClasses;
              }
              return json;
            }
            function makeEdges() {
              var preview = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              var cy = this.cy, options = this.options, presumptiveTargets = this.presumptiveTargets, previewEles = this.previewEles, active = this.active;
              var source = this.sourceNode;
              var target = this.targetNode;
              var classes = preview ? "eh-preview" : "";
              var added = cy.collection();
              var canConnect = this.canConnect(target);
              if (!active) {
                return;
              }
              if (!canConnect) {
                return;
              }
              if (!target || target.size() === 0) {
                previewEles.remove();
                this.emit("cancel", this.mp(), source, presumptiveTargets);
                return;
              }
              if (!preview) {
                previewEles.removeClass("eh-preview").style("events", "");
                this.emit("complete", this.mp(), source, target, previewEles);
                return;
              }
              var source2target = cy.add(getEleJson({
                group: "edges",
                data: {
                  source: source.id(),
                  target: target.id()
                }
              }, this.edgeParams(target), classes));
              added = added.merge(source2target);
              if (preview) {
                this.previewEles = added;
                added.style("events", "no");
              } else {
                added.style("events", "");
                this.emit("complete", this.mp(), source, target, added);
              }
              return this;
            }
            function makePreview() {
              this.makeEdges(true);
              return this;
            }
            function previewShown() {
              return this.previewEles.nonempty() && this.previewEles.inside();
            }
            function removePreview() {
              if (this.previewShown()) {
                this.previewEles.remove();
              }
              return this;
            }
            function updateEdge() {
              var _this = this;
              var sourceNode = this.sourceNode, ghostNode = this.ghostNode, cy = this.cy, mx = this.mx, my = this.my;
              var x = mx;
              var y = my;
              var ghostEdge = void 0, ghostEles = void 0;
              if (!sourceNode) {
                return;
              }
              if (!ghostNode || ghostNode.length === 0 || ghostNode.removed()) {
                ghostEles = this.ghostEles = cy.collection();
                cy.batch(function() {
                  ghostNode = _this.ghostNode = cy.add({
                    group: "nodes",
                    classes: "eh-ghost eh-ghost-node",
                    position: {
                      x: 0,
                      y: 0
                    }
                  });
                  ghostNode.style({
                    "background-color": "blue",
                    "width": 1e-4,
                    "height": 1e-4,
                    "opacity": 0,
                    "events": "no"
                  });
                  var ghostEdgeParams = {};
                  ghostEdge = cy.add(assign({}, ghostEdgeParams, {
                    group: "edges",
                    data: assign({}, ghostEdgeParams.data, {
                      source: sourceNode.id(),
                      target: ghostNode.id()
                    }),
                    classes: "eh-ghost eh-ghost-edge"
                  }));
                  ghostEdge.style({
                    "events": "no"
                  });
                });
                ghostEles.merge(ghostNode).merge(ghostEdge);
              }
              ghostNode.position({ x, y });
              return this;
            }
            module2.exports = {
              makeEdges,
              makePreview,
              removePreview,
              previewShown,
              updateEdge
            };
          }),
          /* 7 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            function disableEdgeEvents() {
              if (this.options.noEdgeEventsInDraw) {
                this.cy.edges().style("events", "no");
              }
              return this;
            }
            function enableEdgeEvents() {
              if (this.options.noEdgeEventsInDraw) {
                this.cy.edges().style("events", "");
              }
              return this;
            }
            module2.exports = { disableEdgeEvents, enableEdgeEvents };
          }),
          /* 8 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            function enable() {
              this.enabled = true;
              this.emit("enable");
              return this;
            }
            function disable() {
              this.enabled = false;
              this.emit("disable");
              return this;
            }
            module2.exports = { enable, disable };
          }),
          /* 9 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var memoize = __webpack_require__(13);
            var sqrt2 = Math.sqrt(2);
            function canStartOn(node) {
              var previewEles = this.previewEles, ghostEles = this.ghostEles;
              var isPreview = function isPreview2(el) {
                return previewEles.anySame(el);
              };
              var isGhost = function isGhost2(el) {
                return ghostEles.anySame(el);
              };
              var isTemp = function isTemp2(el) {
                return isPreview(el) || isGhost(el);
              };
              var enabled = this.enabled, active = this.active, grabbingNode = this.grabbingNode;
              return enabled && !active && !grabbingNode && node != null && node.nonempty() && !isTemp(node);
            }
            function canStartDrawModeOn(node) {
              return this.canStartOn(node) && this.drawMode;
            }
            function canStartNonDrawModeOn(node) {
              return this.canStartOn(node) && !this.drawMode;
            }
            function start(node) {
              var _this = this;
              if (!this.canStartOn(node)) {
                return;
              }
              this.active = true;
              this.sourceNode = node;
              this.sourceNode.addClass("eh-source");
              this.disableGestures();
              this.disableEdgeEvents();
              var getId = function getId2(n) {
                return n.id();
              };
              this.canConnect = memoize(function(target) {
                return _this.options.canConnect(_this.sourceNode, target);
              }, getId);
              this.edgeParams = memoize(function(target) {
                return _this.options.edgeParams(_this.sourceNode, target);
              }, getId);
              this.emit("start", this.hp(), node);
            }
            function update(pos) {
              if (!this.active) {
                return;
              }
              var p = pos;
              this.mx = p.x;
              this.my = p.y;
              this.updateEdge();
              this.throttledSnap();
              return this;
            }
            function snap() {
              if (!this.active || !this.options.snap) {
                return false;
              }
              var cy = this.cy;
              var tgt = this.targetNode;
              var threshold = this.options.snapThreshold;
              var mousePos = this.mp();
              var previewEles = this.previewEles, ghostNode = this.ghostNode;
              var radius = function radius2(n2) {
                return sqrt2 * Math.max(n2.outerWidth(), n2.outerHeight()) / 2;
              };
              var sqDist = function sqDist2(x1, y1, x2, y2) {
                var dx = x2 - x1;
                var dy = y2 - y1;
                return dx * dx + dy * dy;
              };
              var sqDistByPt = function sqDistByPt2(p1, p2) {
                return sqDist(p1.x, p1.y, p2.x, p2.y);
              };
              var nodeSqDist = function nodeSqDist2(n2) {
                return sqDistByPt(n2.position(), mousePos);
              };
              var sqThreshold = function sqThreshold2(n2) {
                var r = radius(n2);
                var t = r + threshold;
                return t * t;
              };
              var isWithinThreshold = function isWithinThreshold2(n2) {
                return nodeSqDist(n2) <= sqThreshold(n2);
              };
              var bbSqDist = function bbSqDist2(n2) {
                var p = n2.position();
                var halfW = n2.outerWidth() / 2;
                var halfH = n2.outerHeight() / 2;
                var nx = p.x;
                var ny = p.y;
                var mx = mousePos.x;
                var my = mousePos.y;
                var x1 = nx - halfW;
                var x2 = nx + halfW;
                var y1 = ny - halfH;
                var y2 = ny + halfH;
                var insideXBounds = x1 <= mx && mx <= x2;
                var insideYBounds = y1 <= my && my <= y2;
                if (insideXBounds && insideYBounds) {
                  return 0;
                } else if (insideXBounds) {
                  var dy1 = my - y1;
                  var dy2 = my - y2;
                  return Math.min(dy1 * dy1, dy2 * dy2);
                } else if (insideYBounds) {
                  var dx1 = mx - x1;
                  var dx2 = mx - x2;
                  return Math.min(dx1 * dx1, dx2 * dx2);
                } else if (mx < x1 && my < y1) {
                  return sqDist(mx, my, x1, y1);
                } else if (mx > x2 && my < y1) {
                  return sqDist(mx, my, x2, y1);
                } else if (mx < x1 && my > y2) {
                  return sqDist(mx, my, x1, y2);
                } else {
                  return sqDist(mx, my, x2, y2);
                }
              };
              var cmpBbSqDist = function cmpBbSqDist2(n1, n2) {
                return bbSqDist(n1) - bbSqDist(n2);
              };
              var cmp = cmpBbSqDist;
              var allowHoverDelay = false;
              var mouseIsInside = function mouseIsInside2(n2) {
                var mp = mousePos;
                var w = n2.outerWidth();
                var halfW = w / 2;
                var h = n2.outerHeight();
                var halfH = h / 2;
                var p = n2.position();
                var x1 = p.x - halfW;
                var x2 = p.x + halfW;
                var y1 = p.y - halfH;
                var y2 = p.y + halfH;
                return x1 <= mp.x && mp.x <= x2 && y1 <= mp.y && mp.y <= y2;
              };
              var isEhEle = function isEhEle2(n2) {
                return n2.same(previewEles) || n2.same(ghostNode);
              };
              var nodesByDist = cy.nodes(function(n2) {
                return !isEhEle(n2) && isWithinThreshold(n2);
              }).sort(cmp);
              var snapped = false;
              if (tgt.nonempty() && !isWithinThreshold(tgt)) {
                this.unpreview(tgt);
              }
              for (var i = 0; i < nodesByDist.length; i++) {
                var n = nodesByDist[i];
                if (n.isParent() && mouseIsInside(n)) {
                  continue;
                }
                if (n.isChild() && !mouseIsInside(n.parent())) {
                  continue;
                }
                if (n.same(tgt) || this.preview(n, allowHoverDelay)) {
                  snapped = true;
                  break;
                }
              }
              return snapped;
            }
            function preview(target) {
              var _this2 = this;
              var allowHoverDelay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var options = this.options, sourceNode = this.sourceNode, ghostNode = this.ghostNode, ghostEles = this.ghostEles, presumptiveTargets = this.presumptiveTargets, previewEles = this.previewEles, active = this.active;
              var source = sourceNode;
              var isGhost = target.same(ghostNode);
              var noEdge = !this.canConnect(target);
              var isExistingTgt = target.same(this.targetNode);
              if (!active || isGhost || noEdge || isExistingTgt) {
                return false;
              }
              if (this.targetNode.nonempty()) {
                this.unpreview(this.targetNode);
              }
              clearTimeout(this.previewTimeout);
              var applyPreview = function applyPreview2() {
                _this2.targetNode = target;
                presumptiveTargets.merge(target);
                target.addClass("eh-presumptive-target");
                target.addClass("eh-target");
                _this2.emit("hoverover", _this2.mp(), source, target);
                target.addClass("eh-preview");
                ghostEles.addClass("eh-preview-active");
                sourceNode.addClass("eh-preview-active");
                target.addClass("eh-preview-active");
                _this2.makePreview();
                _this2.emit("previewon", _this2.mp(), source, target, previewEles);
              };
              if (allowHoverDelay && options.hoverDelay > 0) {
                this.previewTimeout = setTimeout(applyPreview, options.hoverDelay);
              } else {
                applyPreview();
              }
              return true;
            }
            function unpreview(target) {
              if (!this.active) {
                return;
              }
              var previewTimeout = this.previewTimeout, sourceNode = this.sourceNode, previewEles = this.previewEles, ghostEles = this.ghostEles, cy = this.cy;
              clearTimeout(previewTimeout);
              this.previewTimeout = null;
              var source = sourceNode;
              target.removeClass("eh-preview eh-target eh-presumptive-target eh-preview-active");
              ghostEles.removeClass("eh-preview-active");
              sourceNode.removeClass("eh-preview-active");
              this.targetNode = cy.collection();
              this.removePreview(source, target);
              this.emit("hoverout", this.mp(), source, target);
              this.emit("previewoff", this.mp(), source, target, previewEles);
              return this;
            }
            function stop() {
              if (!this.active) {
                return;
              }
              var sourceNode = this.sourceNode, targetNode = this.targetNode, ghostEles = this.ghostEles, presumptiveTargets = this.presumptiveTargets;
              clearTimeout(this.previewTimeout);
              sourceNode.removeClass("eh-source eh-preview-active");
              targetNode.removeClass("eh-target eh-preview eh-hover eh-preview-active");
              presumptiveTargets.removeClass("eh-presumptive-target");
              this.makeEdges();
              ghostEles.remove();
              this.clearCollections();
              this.resetGestures();
              this.enableEdgeEvents();
              this.active = false;
              this.emit("stop", this.mp(), sourceNode);
              return this;
            }
            module2.exports = {
              start,
              update,
              preview,
              unpreview,
              stop,
              snap,
              canStartOn,
              canStartDrawModeOn,
              canStartNonDrawModeOn
            };
          }),
          /* 10 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var defaults = __webpack_require__(4);
            var assign = __webpack_require__(0);
            var throttle = __webpack_require__(14);
            var cyGesturesToggle = __webpack_require__(2);
            var cyListeners = __webpack_require__(3);
            var drawMode = __webpack_require__(5);
            var drawing = __webpack_require__(6);
            var enabling = __webpack_require__(8);
            var gestureLifecycle = __webpack_require__(9);
            var listeners = __webpack_require__(11);
            var edgeEvents = __webpack_require__(7);
            function Edgehandles(options) {
              var cy = options.cy;
              this.cy = cy;
              this.listeners = [];
              this.enabled = true;
              this.drawMode = false;
              this.active = false;
              this.grabbingNode = false;
              this.clearCollections();
              this.mx = 0;
              this.my = 0;
              this.options = assign({}, defaults, options);
              this.saveGestureState();
              this.addListeners();
              this.throttledSnap = throttle(this.snap.bind(this), 1e3 / options.snapFrequency);
              this.preventDefault = function(e) {
                return e.preventDefault();
              };
              this.canConnect = function() {
                return false;
              };
              var supportsPassive = false;
              try {
                var opts = Object.defineProperty({}, "passive", {
                  get: function get() {
                    supportsPassive = true;
                  }
                });
                window.addEventListener("test", null, opts);
              } catch (err) {
              }
              if (supportsPassive) {
                this.windowListenerOptions = { capture: true, passive: false };
              } else {
                this.windowListenerOptions = true;
              }
            }
            var proto = Edgehandles.prototype = {};
            var extend = function extend2(obj) {
              return assign(proto, obj);
            };
            proto.destroy = function() {
              this.removeListeners();
            };
            proto.setOptions = function(options) {
              assign(this.options, options);
            };
            proto.mp = function() {
              return { x: this.mx, y: this.my };
            };
            proto.hp = function() {
              return { x: this.hx, y: this.hy };
            };
            proto.clearCollections = function() {
              var cy = this.cy;
              this.previewEles = cy.collection();
              this.ghostEles = cy.collection();
              this.ghostNode = cy.collection();
              this.sourceNode = cy.collection();
              this.targetNode = cy.collection();
              this.presumptiveTargets = cy.collection();
            };
            [cyGesturesToggle, cyListeners, drawMode, drawing, enabling, gestureLifecycle, listeners, edgeEvents].forEach(extend);
            module2.exports = Edgehandles;
          }),
          /* 11 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function addListeners() {
              var _this = this;
              this.addCytoscapeListeners();
              this.addListener(this.cy, "destroy", function() {
                return _this.destroy();
              });
              return this;
            }
            function removeListeners() {
              for (var i = this.listeners.length - 1; i >= 0; i--) {
                var l = this.listeners[i];
                this.removeListener(l.target, l.event, l.selector, l.callback, l.options);
              }
              return this;
            }
            function getListener(target, event, selector, callback, options) {
              if ((typeof selector === "undefined" ? "undefined" : _typeof(selector)) !== _typeof("")) {
                callback = selector;
                options = callback;
                selector = null;
              }
              if (options == null) {
                options = false;
              }
              return { target, event, selector, callback, options };
            }
            function isDom(target) {
              return target instanceof Element;
            }
            function addListener(target, event, selector, callback, options) {
              var l = getListener(target, event, selector, callback, options);
              this.listeners.push(l);
              if (isDom(l.target)) {
                l.target.addEventListener(l.event, l.callback, l.options);
              } else {
                if (l.selector) {
                  l.target.addListener(l.event, l.selector, l.callback, l.options);
                } else {
                  l.target.addListener(l.event, l.callback, l.options);
                }
              }
              return this;
            }
            function removeListener(target, event, selector, callback, options) {
              var l = getListener(target, event, selector, callback, options);
              for (var i = this.listeners.length - 1; i >= 0; i--) {
                var l2 = this.listeners[i];
                if (l.target === l2.target && l.event === l2.event && (l.selector == null || l.selector === l2.selector) && (l.callback == null || l.callback === l2.callback)) {
                  this.listeners.splice(i, 1);
                  if (isDom(l.target)) {
                    l.target.removeEventListener(l.event, l.callback, l.options);
                  } else {
                    if (l.selector) {
                      l.target.removeListener(l.event, l.selector, l.callback, l.options);
                    } else {
                      l.target.removeListener(l.event, l.callback, l.options);
                    }
                  }
                  break;
                }
              }
              return this;
            }
            function emit(type, position) {
              var cy = this.cy;
              for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              cy.emit({ type: "eh" + type, position }, args);
              return this;
            }
            module2.exports = { addListener, addListeners, removeListener, removeListeners, emit };
          }),
          /* 12 */
          /***/
          (function(module2, exports2, __webpack_require__) {
            "use strict";
            var impl = __webpack_require__(1);
            var register = function register2(cytoscape2) {
              if (!cytoscape2) {
                return;
              }
              cytoscape2("core", "edgehandles", impl);
            };
            if (typeof cytoscape !== "undefined") {
              register(cytoscape);
            }
            module2.exports = register;
          }),
          /* 13 */
          /***/
          (function(module2, exports2) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE_13__;
          }),
          /* 14 */
          /***/
          (function(module2, exports2) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE_14__;
          })
          /******/
        ])
      );
    });
  }
});
export default require_cytoscape_edgehandles();
//# sourceMappingURL=cytoscape-edgehandles.js.map
